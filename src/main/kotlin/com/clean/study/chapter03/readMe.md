# 함수

---
## 목차
1. [작게 만들어라!](#작게-만들어라!)
2. [한가지만 해라!](#한가지만-해라!)
3. [함수 당 추상화 수준은 하나로!](#함수-당-추상화-수준은-하나로!)
4. [Switch 문(조건문)](#Switch-문(조건문))
5. [서술적인 이름을 사용하라!](#서술적인-이름을-사용하라!)
6. [함수 인수](#함수-인수)
7. [부수 효과를 일으키지 마라!](#부수-효과를-일으키지-마라!)
8. [출력 인수](#출력-인수)
9. [명령과 조회를 분리하라!](#명령과-조회를-분리하라!)
10. [오류 코드보다 예외를 사용하라!](#오류-코드보다-예외를-사용하라!)
11. [반복하지 마라!](#반복하지-마라!)
12. [구조적 프로그래밍](#구조적-프로그래밍)
---

## intro
* 함수가 읽기 쉽고 이해하기 쉬우려면 어떻게 해야 할까?
* 읜도를 분명히 표현할는 함수는 어떻게 구현할 수 있을까?
* 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?

---

## 작게 만들어라!
* 함수는 작게 만들어라
* 블록과 들여쓰기
  * if/else, while, switch, for 문 등에 들어가는 블록은 한 줄이어야 한다.
  * 블록안에서 함수를 호출해야 한다.
* 중첩 구조가 생길만큼 함수가 커져서는 안된다. 즉 들여쓰기는 1단, 2단을 넘어서지 않는다.

---

## 한가지만 해라!
* 함수는 한가지를 해야 한다.
* 한가지란 추상화 수준이 하나여야 한다.
  * 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
  * 한 가지만 하는지 판단하는 방법
    * 함수 안에서 의미있는 이름으로 다른 함수를 추출할 수 있다면 그함수는 여러 작업을 한다.

---
## 함수 당 추상화 수준은 하나로!
* 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
* 추상화 수준은 내려가기 규칙을 따른다.
  * 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.

---
## Switch 문(조건문)
* 조건문은 기본적으로 한가지만 수행하지 않는다.
* 이를 유연하게 하기위해서는 조건은 저차원 클래스에 숨기고 반복히지 않는다.(다형성을 이용)
예제는 나중에 준비

---
## 서술적인 이름을 사용하라!
* 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.
* 짧은 이름으로 만들기 어렵다면 길어도 좋다. 다만 서술적인 이름을 사용하라
* 이름을 붙일 떄는 일관성이 있어야 한다. 적어도 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.

---
## 함수 인수
* 함수의 인수는 적을 수록 좋다.
  * 0개 > 1개 > 2개 > 3개 > 4개(이거는 쓰지 말자.)
* 입력 인수
  * 인수를 주고 반환을 받는다 x -> f -> y
* 출력 인수
  * 인수에 결과가 들어간다. x -> f -> x or void
* 입력 인수보다 출력 인수가 이해라기 어렵다. 피하자!

---
  ### 단항 형식
  * 인수에 질문을 던지는 경우
  ```kotlin
  //fileName을 주고 존재하는지 확인
  fun fileExists(fileName: String): Boolean {}
  ```
  * 인수를 먼가로 변환해 결과를 반환하는 경우
  ```kotlin
  //fileName을 주고 InputStream을 반환 받는다.
  fun fileOpen(fileName: String): InputStream {}
  ```
  * 다소 드물게 이벤트 함수도 유용하다.
    * 이벤트 함수는 출력 인수는 없다.
    * 함수 호출을 이벤트로 해석해 입력 인수로 시스템 상태를 바꾼다.
  * 피해야하는 경우
    * 변환 함수에서 출력 인수를 사용하면 혼란을 준다.
      * 입력 인수를 반환하는 함수라면 변환 결과는 반환값으로 돌려주는걸 권장 한다.
    ```kotlin
      fun includeSetupPageInto(pageText: StringBuffer) {}
      fun includeSetupPageInto(pageTest: StringBuffer): StringBuffer {}
    ```
---
  
  ### 플래그 인수
  * 함수에 Boolean 을 넘기는 관례는 피하자.
  * 이미 2가지 이상의 동작한다고 말하고 있다.
---
  
  ### 이항 함수
  * 인수가 두개인 경우는 복수개의 인수가 하나의 값으로 표현되거나 순서가 있는 경우가 좋다.
    ```kotlin
    import java.time.Instant    
    fun checkPoint(x: Int, y: Int) {}
    fun findReportByDateBetween(starDate: Instant, endDate: Instant) {}
    ```
    
---
  ### 삼항 함수
  * 적절한 예제는 찾지 못했지만 권장하지는 않는다.
  * 삼항이 되려면 반드시 이유가 명확해야 한다.

---
  ### 인수 객체
  * 인수가 2 ~ 3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어 본다.
  * 단 인수의 개념을 표현해야 한다.
  ```kotlin
  fun checkPoint(x: Int, y: Int) {}
  // 인수를 x, y로 넘기기 보다는 아래와 같이 인수의 개념을 표현하는 객체로 보내는게 좋다.
  data class Point(val x: Int, val y: Int) {}
  fun checkPoint(point: Point) {}
  ```
---
  ### 인수 목록
  * 인수에 가변인자 혹은 List 형 인수를 보낸다.
  * 단항, 이항, 삼항 함수로 취급할 수 있다.
  ```kotlin
    fun monad(vararg args: Int) {}  
  ```

---
  ### 동사와 키워드
  * 단항 함수의 경우 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
  * 함수 이름에 키워드를 추가한다.
    ```kotlin
    fun writeField(name) {}
    fun assertExpectedEqualsActual(expected: Any, actual: Any) {}
    ```
    
---
## 부수 효과를 일으키지 마라!
* 함수는 하나의 기능만 해야 한다.
* 부수 효과는 시간적인 결합, 순서 종속성을 초래한다.
* 어쩔수 없는 상황이라면 함수 이름에 부수 효과를 나타내야 한다.

---
## 출력 인수
* 인수는 입력 값으로 해석해야 한다.
* 출력 인수는 피하고 대신 this를 사용해 함수가 속한 객체 상태를 변경하는 방식이 좋다.

---
## 명령과 조회를 분리하라!
* 함수는 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.
* 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나다.

---
## 오류 코드보다 예외를 사용하라!
### Try/Catch 블록 뽑아내기
* try/catch 블록도 두가지 일을 한다. 
* 구조에 혼란을 일으키며, 정상 동작과 오류처리 동작을 뒤섞는다.
* try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.
### 오류 처리도 한 가지 작업니다.
### Error 의존성 자석
* Enum의 값을 통해 error를 표현하면 의존성이 강해진다.
* 대신 Exception을 사용하자.

---
## 반복하지 마라!
* 중복이 생기면 관리 포인트가 많아지고 실수를 유도한다.
* 데이터베이스는 연관관계를 통해 중복을 제거하고, 자바는 추상화를 통해 중복을 제거한다.

---
## 구조적 프로그래밍
* 함수는 블록에 입구와 출구가 하나만 존재해야 한다.
* break, continue를 사용하지 않는다.
* 어쩔수 없는 상황이라면 함수를 최대한 작게 만들고 사용한다.
