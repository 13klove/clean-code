# 객체와 자료 구조

---
## 목차


---
## intro
* 변수를 비공개로 정의하는 이유가 있다.
* 변수에 의존하지 않게 하기 위함이다.
* 의존성이 낮아지면 변화에 자유로워 진다.

---
## 자료 추상화
```kotlin
data class Point(
    val x: Double,
    val y: Double
) { }
```
* 변수를 private으로 선언 하더라도 각 값마다 조회 함수와 설정 함수를 제공한다면 구현을 외부로 노출함과 같다.
* 변수 사이에 함수 계층을 넣는게 구현부를 숨기는 행위는 아니다.
* 구현을 감추기 위해서는 추상화가 필요하다.
```kotlin
interface Point {
    fun getX(): Double
    fun getY(): Double
    fun setCartesian(x: Double, y: Double)
    fun getR(): Double
    fun getTheta(): Double
    fun setPolar(r: Double, theta: Double)
}
```
* 클래스 메서드가 접근 정책을 강제한다.
* 좌표를 읽을 때는 각 값을 개별적으로 읽어야 한다.
* 하지만 좌표를 설정할 때는 두 값을 한꺼번에 설정해야 한다.
```kotlin
interface Vehicle {
    fun getFuelTankCapacityInGallons()
    fun getGallonsOfGasoline()
}

interface Vehicle {
    fun getPercentFuelRemaining()
}
```
* 위의 인터페이스에는 차이가 있다. 하나는 구체적이고 하나는 추상적이다.
* 추상화를 시킬떄는 구체화 보다는 getPercentFuelRemaining와 같이 구현부는 어떻게 될지 알 수 없게 하는게 좋다.

---
## 자료/객체 비대칭
* 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
* 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.
* 객체와 자료 구조는 정반대의 개념이다.
* 객체 지향 코드는 새로운 함수를 추가할때 어려움이 있고, 절차 지향 코드는 새로운 자료 구조를 추가할때 어려움이 있다.
* !! 때로는 단순한 자료 구조와 절차적인 코드가 적합한 경우가 있다.

---
## 디미터 법칙(https://mangkyu.tistory.com/147)
* 모듈은 자신이 조작하는 개체의 속사정을 몰라야 한다는 법칙이다.
* 객체는 자료를 숨기고 함수를 공개한다.
  * 디미터 법칙 일부
    * 클래스 C의 메서드 f는 f가 생성한 객체, f인수로 넘어온 객체, c 인스턴스 변수에 저장된 객체
### 기차 충돌
  * 아래 코드가 기차 충돌 코드이다.
  * 단순히 보기에도 조잡하다.
  * getOptions 함수가 반환하는 객체는 getScratchDir을 호출 줄줄이 한다.
  * 기차 충돌 코드보다는 풀어쓰는 코드가 좋다.
  * 풀어쓴 코드의 반환이 자료구조면 이상없지만 객체인 경우 디미터 법칙을 위반 한다.
  * 자료 구조는 무조건 함수 없이 공개 변수만 포함하고 객체는 비공개 변수와 공개 함수를 포함한다면 좋지만 프레임워크와 표준 bean이 존재해 예외도 있다.  
```kotlin
val outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath()
```
```kotlin
val opts = ctxt.getOptions()
val scratchDir = opts.getScratchDir()
val outputDir = scratchDir.getAbsolutePath()
```

### 잡종 구조
* 개발하면 타협을 한다. 절반은 객체, 절반은 자료구조
* 이는 다른 곳에도 영향을 주기에 최대한 피해야 한다.

### 구조체 감추기 ?? 
* 객체에게 뭔가를 하라고 말해야지 속을 드러내라고 하면 안된다.
* 구조체 감추기가 어려운 경우는 왜 필요한가? 사용 목적을 파악하고
* 객체에 명령을 해야 한다.

---
## 자료 전달 객체
* 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다.(DTO)
* 일반적으로 bean 구조다.
* 책에서는 bean 구조를 긍정적으로 보고 있지 않다.

### 활성 레코드
* DTO의 특수한 형태다.
* 공개 변수가 있거나 비공개 변수에 조회, 설정 함수가 있는 자료 구조지만, save, find와 같은 탐색 함수도 제공한다.
* DB, 다른 소스에서 자료를ㄹ 직접 변환하기도 한다.
* 종종 활성 레코드에 비즈니스 규칙을 추가하는 경우가 있는데 이는 적합하지 않다.
* 활성 레코드는 결국 자료 구조다.

## 결론
* 객체는 동작을 공개하고 자료를 숨긴다.
  * 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기 쉬운 반면 기존 객체에 새 동작을 추가하기는 어렵다.
* 자료 구조는 별다른 동작 없이 자료를 노출한다.
  * 기존 자료 구조에 새 동작을 추가하기는 쉬우나 기존 함수에 새 자료 구조를 추가하기는 어렵다.
* 필요에 따라 객체, 절차 지향적으로 유연하게 대처해야 한다.
